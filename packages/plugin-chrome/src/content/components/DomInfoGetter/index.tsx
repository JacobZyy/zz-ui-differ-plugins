import type { DiffResultInfo, NodeInfo, UniqueId } from '@ui-differ/core'
import chalk from '@alita/chalk'
import {
  DESIGN_NODE_PREFIX,
  getNeighborNodeDistance,
  onDomInfoRecorder,
  processMarginCollapsing,
  processPaddingInfo,
  recordHybridNodeMatchResult,
  removeSameSizePositionChildren,
  searchNeighborNodes,
  searchNeighborNodesInitial,
  shrinkRectBounding,
  uiDiff,
} from '@ui-differ/core'
import { Button, Flex, FloatButton, message, Modal, Spin } from 'antd'
import { useRef, useState } from 'react'
import { ChromeMessageType } from '@/types'
import { chromeMessageSender, generateScreenShot } from '@/utils'
import { diffResultFilterRules } from '@/utils/diffResultFilterRules'
import { drawCurrentNodeInfos } from '@/utils/drawCurrentNodeInfos'
import { uploadResultAsJson } from '@/utils/resultUploader'
import styles from './index.module.scss'
import ResultRenderer from './ResultRenderer'
import RootDetector from './RootDetector'

export default function DomInfoGetter() {
  const [messageApi, contextHolder] = message.useMessage({ maxCount: 1 })
  const [modalApi, modalContextHolder] = Modal.useModal()
  const [isModalOpen, setIsModalOpen] = useState(false)
  const [isResultModalOpen, setIsResultModalOpen] = useState(false)
  const rootNodeCls = useRef<string>('.app-wrapper')
  const [screenShotInfo, setScreenShotInfo] = useState<{ imgUrl: string, width: number, height: number }>({
    imgUrl: '',
    width: 0,
    height: 0,
  })
  // ÊØîÂØπÁªìÊûú
  const [diffResultInfo, setDiffResultInfo] = useState<DiffResultInfo[]>([])
  // ËÆæËÆ°Á®øËäÇÁÇπ‰ø°ÊÅØ
  const designNodeInfo = useRef<Map<UniqueId, NodeInfo>>(new Map())
  const flatNodeMap = useRef<Map<UniqueId, NodeInfo>>(new Map())
  const [clipboardLoading, setClipboardLoading] = useState(false)

  /** Ëé∑ÂèñÂâ™ÂàáÊùøÂÜÖÂÆπ */
  const onReadingClipboard = async () => {
    try {
      const designNodeJSON = await navigator.clipboard.readText()
      if (!designNodeJSON || !designNodeJSON.startsWith(DESIGN_NODE_PREFIX)) {
        messageApi.warning('Ââ™ÂàáÊùø‰∏≠Ê≤°ÊúâËÆæËÆ°Á®ø‰ø°ÊÅØ')
        return
      }
      const result = designNodeJSON.replace(DESIGN_NODE_PREFIX, '')
      return result
    }
    catch (error) {
      console.error(error)
      messageApi.error('Ââ™ÂàáÊùøËØªÂèñ‰ø°ÊÅØÂ§±Ë¥•ÔºåËØ∑Êü•ÁúãÊùÉÈôêËÆæÁΩÆ')
    }
    finally {
      setClipboardLoading(false)
    }
  }

  /** Ââ™ÂàáÊùøÂÜÖÂÆπËΩ¨Êç¢Êàêobject */
  const handleGetClipboardContent = async () => {
    try {
      const designNodeJSON = await onReadingClipboard()
      if (!designNodeJSON)
        return
      const nodeList = JSON.parse(designNodeJSON)
      if (!Array.isArray(nodeList)) {
        messageApi.warning('ËÆæËÆ°Á®øËäÇÁÇπ‰∏çÊòØ‰∏Ä‰∏™List')
      }

      const entries = nodeList.map((item: NodeInfo) => [item.uniqueId, item] as const)
      designNodeInfo.current = new Map<UniqueId, NodeInfo>(entries)
    }
    catch (error) {
      console.error(error)
      messageApi.error('JSONËß£ÊûêÂ§±Ë¥•')
    }
  }

  /** ‰øÆÊîπËÆæÂ§áÊ®°Êãü */
  const handleChangeWindowSize = async () => {
    try {
      // Âêëbackground scriptÂèëÈÄÅ‰øÆÊîπÁ™óÂè£Â∞∫ÂØ∏ÁöÑÊ∂àÊÅØ
      const response = await chromeMessageSender({ type: ChromeMessageType.CHANGE_WINDOW_SIZE, data: null })
      if (!response?.success) {
        messageApi.error(response?.message || 'Ë∞ÉÁî®‰øÆÊîπÁ™óÂè£Â∞∫ÂØ∏APIÂ§±Ë¥•')
        return
      }
      messageApi.success('‰øÆÊîπÁ™óÂè£Â∞∫ÂØ∏ÊàêÂäü')
    }
    catch (error) {
      console.error('Ë∞ÉÁî®ËÆæÂ§áÊ®°ÊãüAPIÂ§±Ë¥•:', error)
      messageApi.error('Ë∞ÉÁî®ËÆæÂ§áÊ®°ÊãüAPIÂ§±Ë¥•')
    }
  }

  /** ÈáçÁΩÆËÆæÂ§áÊ®°Êãü */
  const handleResetDeviceEmulation = async () => {
    try {
      // Âêëbackground scriptÂèëÈÄÅÈáçÁΩÆËÆæÂ§áÊ®°ÊãüÁöÑÊ∂àÊÅØ
      const response = await chromeMessageSender({ type: ChromeMessageType.RESET_DEVICE_EMULATION, data: null })
      if (!response?.success) {
        messageApi.error(response?.message || 'Ë∞ÉÁî®ÈáçÁΩÆËÆæÂ§áÊ®°ÊãüAPIÂ§±Ë¥•')
        return
      }
      messageApi.success('ÈáçÁΩÆËÆæÂ§áÊ®°ÊãüÊàêÂäü')
    }
    catch (error) {
      console.error('Ë∞ÉÁî®ÈáçÁΩÆËÆæÂ§áÊ®°ÊãüAPIÂ§±Ë¥•:', error)
      messageApi.error('Ë∞ÉÁî®ÈáçÁΩÆËÆæÂ§áÊ®°ÊãüAPIÂ§±Ë¥•')
    }
  }

  /** ÊâìÂºÄ ÊÉÖÂÜµÂºπÁ™ó */
  const handleOpenModal = async () => {
    try {
      setIsModalOpen(true)
      setClipboardLoading(true)
      await handleChangeWindowSize()
      await handleGetClipboardContent()
    }
    catch (error) {
      console.error(error)
      messageApi.error('Êó†ÊïàÁöÑjsonÔºåËØ∑Á°ÆËÆ§Â§çÂà∂ÁöÑËäÇÁÇπÂÜÖÂÆπ')
    }
    finally {
      setClipboardLoading(false)
    }
  }

  /** ÂÖ≥Èó≠ ÊÉÖÂÜµÂºπÁ™ó */
  const handleCloseModal = () => {
    setIsModalOpen(false)
    // handleResetDeviceEmulation()
  }

  /** ÂÖ≥Èó≠ ÁªìÊûúÂºπÁ™ó */
  const handleCloseResultModal = () => {
    setIsResultModalOpen(false)
  }

  /**
   * domËäÇÁÇπ‰ø°ÊÅØÈìæÂºèÂ§ÑÁêÜ
   */
  const handleDomNodePreProcessChain = async (rootNode: HTMLElement) => {
    flatNodeMap.current = await onDomInfoRecorder(rootNode)
      // .then(filterOutOfDocumentFlowNodes) // ËøáÊª§ÊñáÊ°£ÊµÅ‰πãÂ§ñÁöÑËäÇÁÇπ
      .then(searchNeighborNodesInitial)
      .then(processMarginCollapsing)
      .then(processPaddingInfo)
      .then(shrinkRectBounding)
      .then(removeSameSizePositionChildren)
      .then(searchNeighborNodes)
      .then(getNeighborNodeDistance)
      .then(nodeMap => recordHybridNodeMatchResult(nodeMap, designNodeInfo.current))
  }

  /** ÂºÄÂßãUIÂ∑ÆÂºÇÂØπÊØî */
  const handleStartUiDiff = async (rootNode: HTMLElement) => {
    await handleDomNodePreProcessChain(rootNode)
    // ËäÇÁÇπÂ§ÑÁêÜÂÆåÂêéÂÖ≥Èó≠ÂºπÁ™ó
    setIsModalOpen(false)
    // Á≠âÂæÖÊó∂Èó¥
    await new Promise(resolve => setTimeout(resolve, 1000))
    const diffResult = uiDiff(flatNodeMap.current, designNodeInfo.current)
    const filteredCorrectDiffResult = diffResult.filter(resultInfo => diffResultFilterRules(resultInfo, flatNodeMap.current))
    if (__DEV__) {
      filteredCorrectDiffResult.forEach((resultItem) => {
        const { originNode, designNode, distanceResult } = resultItem
        const nodeEl = document.querySelector(`[unique-id="${originNode.uniqueId}"]`)
        const designNodeName = designNode.nodeName
        chalk.info('========domËäÇÁÇπ:========\n')
        console.info(nodeEl)
        console.info(originNode)
        chalk.info(`========ËÆæËÆ°Á®øËäÇÁÇπ:${designNodeName}========\n`)
        console.info(designNode)
        chalk.info(`========ÊØîÂØπÁªìÊûú:========\n`)
        console.info(distanceResult)
        chalk.info('-------------------------\n')
      })
    }
    const imageResultInfo = await generateScreenShot()
    // ÁºìÂ≠òÊà™Âõæ‰ø°ÊÅØ
    setScreenShotInfo(imageResultInfo)
    setDiffResultInfo(filteredCorrectDiffResult)
    await new Promise(resolve => setTimeout(resolve, 1000))
    await handleResetDeviceEmulation()
    setIsResultModalOpen(true)
  }

  const handleTestDomNodeProcessor = async () => {
    const rootNode = rootNodeCls.current === '.app-wrapper' ? document.getElementById(rootNodeCls.current)?.children[0] : document.querySelector(rootNodeCls.current)
    if (!rootNode)
      return
    const initiedFlatNodeMap = await onDomInfoRecorder(rootNode as HTMLElement)
    console.log('üöÄ ~ handleTestDomNodeProcessor ~ initiedFlatNodeMap:', initiedFlatNodeMap)
    const initiedFlatNodeMapWithInitialNeighborInfos = searchNeighborNodesInitial(initiedFlatNodeMap)
    // Â§ÑÁêÜmargin collapseÈóÆÈ¢ò
    const marginCollapsedFlatNodeMap = processMarginCollapsing(initiedFlatNodeMapWithInitialNeighborInfos)
    // ÂêàÂπ∂Êó†Êïàpadding
    const paddingMergedFlatNodeMap = processPaddingInfo(marginCollapsedFlatNodeMap)
    console.log('üöÄ ~ handleTestDomNodeProcessor ~ paddingMergedFlatNodeMap:', paddingMergedFlatNodeMap)
    const boundingRectShrinkedNodeMap = shrinkRectBounding(paddingMergedFlatNodeMap)
    console.log('üöÄ ~ handleTestDomNodeProcessor ~ shrinkRectBounding:', boundingRectShrinkedNodeMap)
    // ÁßªÈô§Áõ∏ÂêåÂ∞∫ÂØ∏„ÄÅ‰ΩçÁΩÆÁöÑÂ≠êËäÇÁÇπ
    const removedSameSizePositionChildrenFlatNodeMap = await removeSameSizePositionChildren(boundingRectShrinkedNodeMap)
    // ÊêúÁ¥¢ÈÇªÂ±ÖËäÇÁÇπ
    flatNodeMap.current = searchNeighborNodes(removedSameSizePositionChildrenFlatNodeMap)

    // await handleDomNodePreProcessChain(rootNode as HTMLElement)
    // console.log('üöÄ ~ handleTestDomNodeProcessor ~ flatNodeMap.current:', flatNodeMap.current)
    drawCurrentNodeInfos(flatNodeMap.current)

    // const targetEl = document.querySelector('.z-nav-bar')
    // const targetId = targetEl?.getAttribute('unique-id')
    // const targetChildEl = targetEl?.querySelector('.z-nav-bar__left')
    // const targetChildId = targetChildEl?.getAttribute('unique-id')
    // if (!targetChildId || !targetId)
    //   return
    // const initNode = initiedFlatNodeMap.get(targetId)
    // const initChildNode = initiedFlatNodeMap.get(targetChildId)
    // const marginCollapsedNode = marginCollapsedFlatNodeMap.get(targetId)
    // const marginCollapsedChildNode = marginCollapsedFlatNodeMap.get(targetChildId)
    // const paddingMergedNode = paddingMergedFlatNodeMap.get(targetId)
    // const paddingMergedChildNode = paddingMergedFlatNodeMap.get(targetChildId)
    // const removedSameSizePositionChildrenNode = removedSameSizePositionChildrenFlatNodeMap.get(targetId)
    // const removedSameSizePositionChildrenChildNode = removedSameSizePositionChildrenFlatNodeMap.get(targetChildId)
    // const flatNode = flatNodeMap.get(targetId)
    // const flatChildNode = flatNodeMap.get(targetChildId)
  }

  const handleFinishResult = async (resultImage?: string) => {
    const resultData = {
      diffResultInfo,
      domNodeList: Array.from(flatNodeMap.current.values()),
      designNodeList: Array.from(designNodeInfo.current.values()),
    }
    try {
      // ‰∏ä‰º† JSON Êñá‰ª∂Âπ∂Ëé∑Âèñ URL
      const jsonUrl = await uploadResultAsJson(resultData)
      const clipboardData = {
        screenShot: screenShotInfo.imgUrl,
        resultImage,
        diffResultJson: jsonUrl,
        pageUrl: location.href,
      }
      // Â∞Ü‰∏ä‰º†ÈìæÊé•Â§çÂà∂Âà∞Ââ™ÂàáÊùø
      await navigator.clipboard.writeText(JSON.stringify(clipboardData))
      chalk.info(JSON.stringify(clipboardData, null, 2))
      await new Promise(resolve => setTimeout(resolve, 200))
      setIsResultModalOpen(false)
      await modalApi.success({
        title: 'Ëá™Âä®Ëµ∞Êü•ÂÆåÊàê',
        content: 'ÁªìÊûúÊñá‰ª∂Â∑≤‰∏ä‰º†Âπ∂Â§çÂà∂ÈìæÊé•Âà∞Ââ™ÂàáÊùøÔºåÁÇπÂáªÈìæÊé•Êèê‰∫§ÁªìÊûú',
        okText: 'ÂéªÊèê‰∫§',
      })
      window.open('https://doc.weixin.qq.com/smartsheet/form/1_wpnn3gDAAARYuiUwJ_LnVQrdgd81PAPw_a8bcdd')
    }
    catch (error) {
      console.error('‰∏ä‰º†ËøáÁ®ãÂá∫Èîô:', error)
      messageApi.error('‰∏ä‰º†ËøáÁ®ãÂá∫Èîô')
    }
  }

  const handleTestCanvas = () => {
    const imageResultInfo = {
      imgUrl: 'https://pic2.zhuanstatic.com/zhuanzh/0296d4c8-0822-44ee-a53c-1a4e9a14481b.png',
      width: 375,
      height: 1623,
    }
    // ÁºìÂ≠òÊà™Âõæ‰ø°ÊÅØ
    setScreenShotInfo(imageResultInfo)
    setIsResultModalOpen(true)
  }

  const handleUpdateRootNodeName = (rootClsName: string) => {
    rootNodeCls.current = rootClsName
  }

  return (
    <>
      {contextHolder}
      {modalContextHolder}
      <FloatButton
        className={styles.floatButton}
        icon={<span className="ui-differ-icon" />}
        type="default"
        onClick={handleOpenModal}
      />

      <Modal
        title="DomËäÇÁÇπÊ£ÄÊµã"
        open={isModalOpen}
        onCancel={handleCloseModal}
        footer={null}
        maskClosable={false}
        width={800}
        centered
        destroyOnHidden
      >
        <Spin spinning={clipboardLoading} tip="ËØªÂèñÂâ™ÂàáÊùø‰ø°ÊÅØ‰∏≠...">
          <RootDetector onClose={handleCloseModal} onConfirm={handleStartUiDiff} updateRootNodeName={handleUpdateRootNodeName} />
          {!!__DEV__ && (
            <Flex wrap gap={16}>
              <Button variant="filled" color="magenta" onClick={handleResetDeviceEmulation}>
                ÈáçÁΩÆËÆæÂ§áÊ®°Êãü
              </Button>
              <Button variant="filled" color="gold" onClick={handleChangeWindowSize}>
                Ë∞ÉÊï¥ËÆæÂ§áÊ®°Êãü
              </Button>
              <Button variant="filled" color="blue" onClick={handleGetClipboardContent}>
                Ëé∑ÂèñÂâ™ÂàáÊùøÂÜÖÂÆπ
              </Button>
              <Button variant="filled" color="red" onClick={handleTestDomNodeProcessor}>
                domÊï∞ÊçÆÂ§ÑÁêÜÊµãËØï
              </Button>
              <Button variant="filled" color="volcano" onClick={handleTestCanvas}>
                canvasÊµãËØï
              </Button>

            </Flex>
          )}
        </Spin>
      </Modal>

      <Modal
        title="DOMËäÇÁÇπÊ£ÄÊµãÁªìÊûúÂ±ïÁ§∫"
        rootClassName={styles.uiDifferResultModal}
        open={isResultModalOpen}
        onCancel={handleCloseResultModal}
        footer={null}
        maskClosable={false}
        width={800}
        centered
        destroyOnHidden
      >
        <ResultRenderer
          onFinishResult={handleFinishResult}
          diffResultInfo={diffResultInfo}
          screenShotHeight={screenShotInfo.height}
          screenShotWidth={screenShotInfo.width}
          screenShot={screenShotInfo.imgUrl}
        />
      </Modal>

    </>
  )
}
